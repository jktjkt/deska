% vim: spelllang=en spell textwidth=120
\documentclass[deska]{subfiles}
\begin{document}

\chapter{The Console Application}
\label{sec:usage-cli}

\begin{abstract}
The following chapter serves as a users' guide to the CLI application.
\end{abstract}

\section{Prompt and context}

When the CLI is started, you will se the command prompt, where the commands could be entered. The prompt has its context.
The context is something like a path to some object where each object in the path is nested to the previous. 
It means, that all commands manipulating, or working with objects will now be related to this context. This behavior
is very similar to an ordinary unix prompt where under context we can imagine a current directory where we are. Actually the
context could represent a set of objects, because it can contain also filters, not only single object definitions.
We will talk about filters later. Context means, that all commands manipulating, or working with objects will now be related to
object or objects represented by this context. This behavior is very similar to an ordinary unix prompt where under context
we can imagine a current directory where we are. In unix prompt all commands like "ls", "cd", "mv" and so on are also related
to the current directory.

You can go into the context of some object simply by typing its kind and name. For example:

\begin{minted}{text}
> host hpv2
host hpv2> interface eth0
host hpv2->interface eth0>
\end{minted}

Now we are in context of object interface "interface eth0" embedded in "host hpv2". Steping from the context is done by
keyword "end".

There is also a possibility of shortened types of jumping into context of a nested object using "->" in the name of the
object.

\begin{minted}{text}
> interface hpv2->eth0
host hpv2->interface eth0> end
host hpv2> end
>
\end{minted}

The "interface hpv2->eth0" is equivalent to "host hpv2 interface eth0". So also keyword "end" will jump into context of
"host hpv2" and not to a "top-level" context. This shortened version could be used also in commands manipulating with
objects.

\subsection{Filters}

Now we can describe, how to use filters in the context. Filter could be entered by typing kind name followed by keyword
"where" and then writing filter definition in braces. The filter definition syntax could be described as this recursive
structure:

\begin{minted}{text}
<filter>     = (<andFilter>) or (<orFilter>) or (<expression>)
<andFilter>  = list of <filter> separated by '&'
<orFilter>   = list of <filter> separated by '|'
<expression> = comparison of attribute name and some value
\end{minted}

Note that each part of the filter has to be in braces. In a filter for a specific kind you can use expressions containing
attributes directly from this kind, or kinds, that are contained in this one. There is also possibility to use expressions
containing attributes of any kind, that is in some relation wtih this one. With relations we mean standard Deska relations
like "embed into", "contains" and "containable" and "refers to". These attributes should be prefixed by name of their
kind with dot. For example "interface.ipv4". There are two sets of operators, that can be used in expressions. First
set is for standard attributes: "<", ">", "<=", ">=", "!=" or "<>" and "=" or "==". The second set is for identifiers
sets. There are only two operators: "contains" and "not\_contains".

Filters are an exception in a concept of context. Normally we can not be in context of a specific interface without being
in context of its host. Filters are a little bit different as a set of interfaces should not have one shared parent. So
when being in top-level context, we can write filter on any kind. When being in context of some object, this filter
relates to this context and we can filter only on objects and kinds, that are embedded directly or recursively in this object.

Now we will show some examples of filters:

Filter on hardware from a specific vendor:
\begin{minted}{text}
> hardware where (vendor == HP)
filter on hardware> end
>
\end{minted}

This was filter using attribute directly from hardware. We can also ask for the same thing using attribute from vendor.
\begin{minted}{text}
> hardware where (vendor.name == HP)
filter on hardware> end
>
\end{minted}

Now we can write filter for hardware not puchased in 2010 serving as www server.

\begin{minted}{text}
> hardware where (((purchase < 2010/01/01) | (purchase > 2010/12/31)) & (host.service contains www))
filter on hardware> end
>
\end{minted}

There are also two special filters. One is for selecting all instances of a specific kind. This is done by keyword "all".
\begin{minted}{text}
> all host
filter on host> end
>
\end{minted}

We can use this filter also for for example all interfaces of a specific host.
\begin{minted}{text}
> host hpv2
host hpv2> all interface
host hpv2->filter on interface> end
host hpv2>
>
\end{minted}

The second filter is for obtaining last added embedded object using keyword "new". The usage is the same as in case of
"all". We will describe usage of both keywords later.

\section{Showing content of the DB}

There are two way, how to look, what is currently stored in the DB. First way is showing content of the whole DB. This
is done by command "dump".

Command "dump" shows all objects in the DB including their attributes and also nested objects recursively. No other
relations were displayed here. You can also use command "dump" with parameter. This parameter stands for a filename and
the dump will be then stored in this file. The sample dump can look like this:
\begin{minted}{text}
> dump
host hpv2
    no hardware
    note_host "Sample host"
    service [ftp, www]
    no template_host
    no virtual_hardware
    interface eth0
        ip4 192.168.2.34
        no ip6
        mac 2E:4A:AB:89:6C:7B
        no network
        no note
        no template_interface
    end
end
host golias2
    no hardware
    note_host "Another sample host"
    no service
    no template_host
    no virtual_hardware
end
service www
    no note
end
service ftp
    no note
end
service dns
    no note
end
\end{minted}

Another method is using command "show". When there is no context, it shows only list of top-level objects without any
additional information. In context the command shows information about object or objects from the context. The
information contains all attributes with resolved values from templates. When some attributes value was taken from
a template, information about source of this value is also printed. If some object is contained in one being currently
printed, its attributes and nsted kinds will be printed under attribute referring to this object. Nested objects are
printed in the way similar to output fromcommand "dump". Example of output from "show" on host containing some hardware
through attribute "hardware" with attribute "ram" inherited from template for hardware with name "hp357":

\begin{minted}{text}
> host hpv2
host hpv2> show
hardware hpv2
cpu_ht 1
cpu_num 4
no hepcpec
host hpv2
no note_hardware
purchase 2011-12-23
ram 4096 -> hp357
template_hardware hp357
no vendor
warranty 2013-12-23
note_host "Sample host"
no service [ftp, www]
no template_host
no virtual_hardware
interface eth0
    ip4 192.168.2.34
    no ip6
    mac 2E:4A:AB:89:6C:7B
    no network
    no note
    no template_interface
end
\end{minted}

Command "show" could be used also for printing information about objects not in current context. Like "show host hpv2" or
"show host hpv2 interface eth0". Ths will not change current context and shows information about object in parameter.
The parameter is also relative to current context. It means, that in context of host "hpv2" you can type "show interface eth0"
for showing information about interface "eth0" nested in host "hpv2".

\section{Database Backup}
\label{sec:cli-db-backup}

FIXME: describe me

\end{document}
