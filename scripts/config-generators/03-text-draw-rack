#!/usr/bin/python
import sys
import time
# FIXME: this shall be removed in the final version
sys.path = ["/home/jkt/work/fzu/deska/src/deska/python", "/home/jkt/work/fzu/deska/_build"] + sys.path
import deska

import numpy as np
import matplotlib
matplotlib.use("SVG")
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.lines as mlines
import matplotlib.transforms as mtransforms

deska.init()

t1 = time.time()
boxes = deska.box._all()
t2 = time.time()

queue = ["serverovna"]
keys = boxes.keys()
keys.remove("serverovna")
res = {}
res[None] = [k for k in keys if boxes[k].inside is None]

while len(queue):
    current = queue.pop(0)
    children = [x for x in keys if boxes[x].inside == current]
    queue.extend(children)
    res[current] = children

def position_sorter(item):
    if boxes[item].x is not None:
        x = boxes[item].x
    else:
        x = 1
    if boxes[item].y is not None:
        y = boxes[item].y
    else:
        y = 1
    if boxes[item].z is not None:
        z = boxes[item].z
    else:
        z = 1
    return (-y, x, z, item)

def walk_boxes(key, parent_modelbox, boundary):
    my_modelbox = None
    my_modelbox_obj = None
    message = None
    if boxes[key].direct_modelbox is not None:
        my_modelbox = deska.modelbox[deska.modelbox.name == boxes[key].direct_modelbox]
    elif boxes[key].hardware is not None:
        my_modelhw = deska.modelhardware[deska.hardware.name == key]
        my_modelhw_obj = my_modelhw[my_modelhw.keys()[0]]
        my_modelbox = deska.modelbox[deska.modelbox.name == my_modelhw_obj.modelbox]
        # We really have to ask for the modelhw data (the server supports just
        # one level of joining), and when we're at that point, it feels faster not
        # to ask the database for a join, but just pass the name.
        # The timing appears to have a pretty high noise level, so chances are
        # that there is no measurable difference.
        #my_modelbox = deska.modelbox[deska.modelhardware.name == my_modelhw.keys()[0]]
        if not len(my_modelbox):
            my_modelbox = None
    if my_modelbox is not None:
        additional = ": %s %s" % (my_modelbox.keys()[0], repr(my_modelbox.values()[0]))
        my_modelbox_obj = my_modelbox[my_modelbox.keys()[0]]
    elif message is not None:
        additional = message
    else:
        additional = " [no modelbox]"

    # Child boxes immediately nested in this one
    all_children = sorted(res[key], key=position_sorter)

    (x, y, width, height) = boundary
    if parent_modelbox is not None and parent_modelbox.internal_width is not None:
        # The parent modelbox provides information about its dimensions
        if parent_modelbox.internal_depth not in (None, 0, 1):
            # We do not support drawing of these boxes
            raise RuntimeError, "Parent of box %s has weird depth, sorry" % key
        internal_width = parent.internal_width
        if internal_width < 1:
            internal_width = 1
        internal_height = parent.internal_height
        if internal_height < 1:
            internal_height = 1
        pos = np.mgrid[0:1:
        print key
        pass
    else:
        # We do not know about our exact positioning, so we have to compute one.
        # Given that the parent does not say anything about proper spacing etc,
        # let's just assume a uniform distribution.
        if len(all_children):
            stepping = len(all_children)
        else:
            stepping = 1
        # generate uniform spacing
        pos = np.mgrid[0:1:stepping, 0:1:1].reshape(2, -1)
        print key
        print pos
        pass

    for x in all_children:
        walk_boxes(x, my_modelbox_obj, boundary)



font = "sans-serif"
fig = plt.figure(figsize=(10,10))
#fig = plt.figure()
ax = plt.axes([0,0,1,1])

walk_boxes("serverovna", None, (0, 0, 10, 10))

# create 3x3 grid to plot the artists
pos = np.mgrid[0.2:0.8:3j, 0.2:0.8:3j].reshape(2, -1)

patches = []

# add a rectangle
art = mpatches.Rectangle(
    #(0,0), 0.05, 0.1,
    pos[:,1] - np.array([0.025, 0.05]), 0.05, 0.1,
        ec="none", label="pwn")
patches.append(art)

plt.text(pos[0,1], pos[1,1]-0.15, "Rectangle", ha="center",
        family=font, size=14)

colors = 100*np.random.rand(len(patches))
collection = PatchCollection(patches, cmap=matplotlib.cm.jet, alpha=0.4)
collection.set_array(np.array(colors))
ax.add_collection(collection)
ax.set_xticks([])
ax.set_yticks([])

plt.savefig("rackview.svg")

t3 = time.time()

file("__timing-stats", "wb").write(
    "boxes: total %s, main query %s, loop %s\n" % (t3 - t1, t2 - t1, t3 - t2))
