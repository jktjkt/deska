\documentclass[deska]{subfiles}
\begin{document}

\chapter{Deska DB}
\label{sec:deska-db}

\begin{abstract}
FIXME: talk about deska db - versioning, data resolving
\end{abstract}

In this chapter you can find how the deska db works, how the data versioning, templating and other deska's features are done.\\
Almost all tables and stored procedures are generated by sql-generator described in \secref{sec:sql-generator}.

\section{Versioning}
\label{sec:versioning}

The database can return object's data in any version in which it exists. This could be done due to history tables that are generated for each table defined by user.\\
Each history table contains, in addition to attributes in the table defined by user, attributes {\tt version} and {\tt dest\_bit}. In version attribute is information about the changeset in which the object was modified. {\tt dest\_bit} attribute set to 1 means that the object is deleted, default value is 0.\\

\subsection{Data Modification}
\begin{center}

\begin{table}
    \caption{history of hardware table}
    \label{tab-example-hardwarehist}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_history}\\
    \hline
    name & uid & purchase & note & dets\_bit & version\\
    \hline
    h1 & 1 & & & 0 & 1 \\
    h2 & 2 & & & 0 & 1 \\
    h2 & 2 & & note & 0 & 2 \\
    h2 & 2 & 01-01-2011 & note & 0 & 3 \\
    h1 & 2 & & & 1 & 3 \\
    \hline
\end{tabular}
\end{table}

\end{center}

In table \ref{tab-example-hardwarehist} is example of hardware's history table. This is how the hardware\_history table looks like after following operations. 
\begin{itemize}
    \item In changeset 1 were inserted hardware h1, h2.
    \item In changeset 2 was h2's note attribute set to note.
    \item In changeset 3 was h2's purchase attribute set to 01-01-2011 and hardware h1 was deleted.
\end{itemize}


If the table \ref{tab-example-hardwarehist} was only a piece of data from hardware\_history table then we could not recognize if these objects were in changeset 1 created or some of their attributes were just set.\\
In row with hardware h2, version 3 we can see that when object is modified, row with its actual data and id of current changeset is inserted into history table, after that the attribute which has to be modified is set.\\
In words of stored procedures it could be written so:\\

\begin{minted}{sql}
select startchangeset();
select hardware_add('h1');
select hardware_add('h2');
select commitchangeset('.');

select startchangeset();
select hardware_set_note('h2','note');
select commitchangeset('.');

select startchangeset();
select hardware_set_purchase('h2','01-01-2011');
select hardware_del('h1');
select commitchangeset('.');
\end{minted}

\subsection{Retrieve Object Data}

If we would like to get data of some objects in given version. We have to find the objects' last modification. To find the really last objects' modification, we need to know version table.\\
At the time of changeset commit, table with versions is updated. For our example it could looks like \ref{tab-example-version}.\\
Important infomation for us are id and num. id is id of changeset from which the version num was created. The version number num is an increasing sequence, if version num2 was created on the base of version num1 then num1 < num2.

\begin{center}

\begin{table}
    \caption{version table}
    \label{tab-example-version}
\begin{tabular}{ | l | l | l | l | l |}
    \hline
    \multicolumn{5}{|c|}{version}\\
    \hline
    id & num & author & timestamp & message\\
    \hline
    0 & 1 & martina & 2011-12-17 17:04:29.56794 & Initial revision\\
    1 & 2 & martina & 2011-12-17 17:04:47.876152 & .\\
    2 & 3 & martina & 2011-12-17 17:04:54.731837 & .\\
    3 & 4 & martina & 2011-12-17 17:05:12.489788 & .\\
    \hline
\end{tabular}
\end{table}

\end{center}


There are some examples of data retriving, results are in table \ref{tab-select-hardware} and table \ref{tab-select-hardware-v3}.\\

\begin{minted}{sql}
--functions for data retrieving without parameters returns the most actual data
select * from hardware_data_version();
select * from hardware_data_version(3);
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware\_data\_version()}
    \label{tab-select-hardware}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_data\_version()}\\
    \hline
    uid & name & note & purchase & version & dets\_bit\\
    \hline
    2 & h2 & note & 2011-01-01 & 3 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

\begin{center}

\begin{table}
    \caption{hardware\_data\_version(3)}
    \label{tab-select-hardware-v3}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_data\_version(3)}\\
    \hline
    uid & name & note & purchase & version & dets\_bit\\
    \hline
    1 & h1 &  &  & 1 & 0\\
    2 & h2 & note &  & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

\subsection{Commit}
Commit function selects objects from history table of given kind which were just added, deleted or updated in the current changeset. Rows that belong to added objects are inserted into given kind's table in the schema production. Rows that belong to deleted objects are deleted from kind's table in the schema production. And rows that belong to updated objects are updated in kind's table in the schema production.\\
Commits from our example will cause these changes:
\begin{itemize}
    \item After changeset 1 rows with hardware h1, h2 will be inserted.
    \item After changeset 2 h2's note attribute will be updated.
    \item After changeset 3 h2's purchase attribute will be updated and hardware h1 will be deleted.
\end{itemize}

\section{Refers To}
\label{sec:db-refs-to}
If the table is in the {\tt REFERS TO} relation with another, it has to have column that refers to the {\tt uid} column of the another table. This column, which refers to the {\tt uid} column of another table, we will call here {\em refuid}.\\
Stored procedures for setting refuid columns expect as parameter some value of name attribute from referenced table. The given name is found in referenced table and proper {\tt uid} is set as value of refuid column instead of the name.

Here is an example of setting refuid column. The result of these selects is in tables \ref{tab-refs-hardware} and  \ref{tab-refs-vendor}.
\begin{minted}{sql}
select startchangeset();
select vendor_add('v1');
select vendor_add('v2');
select hardware_add('h1');
select hardware_set_vendor('h1','v2');
select commitchangeset('.');

select * from hardware;
select * from vendor;
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware}
    \label{tab-refs-hardware}
\begin{tabular}{ | l | l | l | l | l |}
    \hline
    \multicolumn{5}{|c|}{hardware}\\
    \hline
    uid & name & note & purchase & vendor\\
    \hline
    1 & h1 &  &  & 2\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{vendor}
    \label{tab-refs-vendor}
\begin{tabular}{ | l | l |}
    \hline
    \multicolumn{2}{|c|}{vendor}\\
    \hline
    uid & name \\
    \hline
    1 & v1\\
    2 & v2\\
    \hline
\end{tabular}
\end{table}

\end{center}

\section{Object Embedding}
Object embedding is described in \ref{sec:relation-embed-into}. The object which is embedded into another object could be identified by the global name, pair of object's local name and parent's name. Embedded objects have an attribute which refer to the parent object's uid. With this attribute is manipulated in the same way as with the refuid attributes described in \ref{sec:db-refs-to}\\
The following example shows how to work with embedding, the table identifier is embedded into the table host. Result of these selects is in the tables \ref{tab-embed-host} and \ref{tab-embed-interface}

\begin{minted}{sql}
select startchangeset();
select host_add('h1');
select host_add('h2');
select interface_add('h1->i1');
select interface_add('h1->i2');
select interface_add('h2->i1');
select commitchangeset('r2');
\end{minted}

\begin{center}

\begin{table}
    \caption{host}
    \label{tab-embed-host}
\begin{tabular}{ | l | l | }
    \hline
    \multicolumn{2}{|c|}{host}\\
    \hline
    uid & name \\
    \hline
    1 & h1\\
    2 & h2\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{interface}
    \label{tab-embed-interface}
\begin{tabular}{ | l | l | l | l | }
    \hline
    \multicolumn{4}{|c|}{interface}\\
    \hline
    uid & name & host & note\\
    \hline
    1 & i1 & 1 & \\
    2 & i2 & 1 & \\
    3 & i1 & 2 & \\
    \hline
\end{tabular}
\end{table}

\end{center}

\section{Templates}
{\tt TEMPLATIZED} relation which is described in \ref{sec:relation-templatized} is implemented by template tables. 

\subsection{Value inheritence}
The columns, which are a part of some {\tt COMPOSITION} relation or {\tt EMBED INTO} relation, can not inherit its value from templates. Therefor these columns are not present in the template table. All other attributes from the templated table are also in the template table.\\
As the template tables are templated by themself, object can inherit value of its attributes transitively from more templates.\\
To ensure right data retrieving from given version, template tables need to have history tables as well.\\
Tables in the schema production store resolved data.\\
The following example shows how we can work with the templated tables. The hardware table is templated by the hardware\_template table. The result of these selects is in tables \ref{tab-templ-hwhist} and \ref{tab-templ-hwtemplhist}.

\begin{minted}{sql}
select startchangeset();
select hardware_template_add('t1');
select hardware_template_set_note('t1','note from template t1');
select hardware_template_set_purchase('t1','01-01-2011');
select hardware_add('h1');
select hardware_set_template_hw('h1','t1');
select commitchangeset('r2');

select startchangeset();
select vendor_add('v1');
select hardware_template_add('t2');
select hardware_template_set_vendor('t2','v1');
select hardware_template_set_purchase('t2','01-01-2011');
select hardware_template_set_template_hw('t1','t2');
select commitchangeset('r3');

select startchangeset();
select hardware_set_note('h1','own h1 note');
select commitchangeset('r4');
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware\_history}
    \label{tab-templ-hwhist}
\begin{tabular}{ | l | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{8}{|c|}{hardware\_history}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & version & dest\_bit\\
    \hline
    1 & h1 &  &  &  & 1 & 1 & 0\\
    1 & h1 & own h1 note &  &  & 1 & 3 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template\_history}
    \label{tab-templ-hwtemplhist}
\begin{tabular}{ | l | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{8}{|c|}{hardware\_template\_history}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & version & dest\_bit\\
    \hline
    1 & t1 & note from template t1 & 2011-01-01 &  &  & 1 & 0\\
    2 & t2 &  & 2011-01-01 & 1 &  & 2 & 0\\
    1 & t1 & note from template t1 & 2011-01-01 &  & 2 & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

By calling the following commands we can get resolved data, it means with inherited values.\\
It is possible to get resolved data even with the data origin, this function is introduced in section about multi-value references \ref{sec:multi-val}.
\begin{minted}{sql}
--from version 'r3'
select * from hardware_resolved_data(3);
select * from hardware_template_resolved_data(3);
\end{minted}

Results are in \ref{tab-templ-hwres2} and \ref{tab-templ-hwtemplres2}.

\begin{minted}{sql}
--in production are the newest resolved data
select * from hardware;
select * from hardware_template;
\end{minted}
Results are in \ref{tab-templ-hw} and \ref{tab-templ-hwtempl}.

\begin{center}

\begin{table}
    \caption{hardware\_resolved\_data(3)}
    \label{tab-templ-hwres2}
\begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    \multicolumn{7}{|c|}{hardware\_resolved\_data()}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & dest\_bit\\
    \hline
    h1 & 1 & note from template t1 & 2011-01-01 & 1 & 1 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template\_resolved\_data(3)}
    \label{tab-templ-hwtemplres2}
\begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    \multicolumn{7}{|c|}{hardware\_template\_resolved\_data(3)}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & dest\_bit\\
    \hline
    t2 & 2 &  & 2011-01-01 & 1 &  & 0\\
    t1 & 1 & note from template t1 & 2011-01-01 & 1 & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware}
    \label{tab-templ-hw}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw\\
    \hline
    1 & h1 & own h1 note & 2011-01-01 & 1 & 1\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template}
    \label{tab-templ-hwtempl}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_template}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw\\
    \hline
    1 & t1 & note from template t1 & 2011-01-01 & 1 & 2\\
    2 & t2 &  & 2011-01-01 & 1 & \\
    \hline
\end{tabular}
\end{table}

\end{center}

\subsection{Commit of Templated Tables}
As data in the production schema are resolved, it is needed during commit find modified objects and resolve their data. We should keep in mind that object's data could be modified even by modification in the object that templates this object.\\
Commit of templated table is composed of:
\begin{enumerate}
    \item find all objects in the template table that were modified in the current changeset
    \item find all objects in the template table that can tranistively inherit data from objects in step 1
    \item find all objetcs in the templated table that inherit data from objects in step 2
    \item resolve data of objects from step 3
    \item process data from step 4 as it was selected from history table of not templated table
\end{enumerate}

\section{Diff}
Modifications which were done between two versions or inside a temporary changeset could be listed by diff functions. Diff has these stages:
\begin{enumerate}
    \item init diff
    \item process diff data
    \item terminate diff
\end{enumerate}
Stage init diff creates temporary table with almost all data needed to get list of all modifications.
More init functions exist, one for diff between two versions and one for diff between state in temporary changeset and in its parent version. For templated kinds these init diff functions exist even in resolved modification.\\
Temporary table created in init diff stage could be then processed by diff functions. Each type of "basic modification" described in DBAPI \ref{sec:dbapi-protocol} is listed by separate diff function. Basic modifications setting a single attribute are listed by one function for all attributes of {\tt identifier\_set} type and next one for the rest of attributes.\\
The example below shows how you can select changes between versions.

\begin{minted}{sql}
select startchangeset();
select hardware_add('h1');
select hardware_add('h2');
select hardware_set_purchase('h1','02-12-2011');
select commitchangeset('r2');

select startchangeset();
select hardware_set_purchase('h1','01-01-2012');
select hardware_add('h3');
select hardware_del('h2');
select hardware_set_name('h1','hr');
select commitchangeset('r3');

--init
select hardware_init_diff(2,3);

--process diff data
select * from hardware_diff_created();
--returns h3

select * from hardware_diff_deleted();
--returns h2

select * from hardware_diff_rename();
--returns oldname:h1   newname:hr

select * from hardware_diff_set_attributes(2,3);
--returns objname:hr   attribute:purchase   olddata:2011-02-12   newdata:2012-01-01

--terminate
select hardware_terminate_diff();
\end{minted}

\section{Composition}
Composition is described in \ref{sec:relation-contains}
Linking objects with the same name from different tables is maintained by before and after insert and update triggers. These triggers ensure even disjoining if one of linked objects is renamed or deleted and can immediately join renamed object with another one.\\
Condition that one object could be contained in at most one another object is checked by the check constraints. When the table represents kind that is containable to more than one kind, the containable table has this check constraint.\\
Following example shows, how the objects in composition relation are linked and disjoined. Result is in tables \ref{tab-comp-box}, \ref{tab-comp-hw} and \ref{tab-comp-switch}.

\begin{minted}{sql}
select startchangeset();
select hardware_add('h1');
select hardware_add('h2');
select hardware_add('h3');
select box_add('h1');
select box_add('h3');

--select switch_add('h1');
--would raise exception (violates check constraint) - h1 switch and h1 hardware can not contain the same box
select box_add('o1');
select commitchangeset('r2');

select startchangeset();
--renamed hardware is immediately linked with box with the same name
select hardware_set_name('h2','o1');
select hardware_del('h3');
--box h3 is now free, switch h3 could containt box h3
select switch_add('h3');
select commitchangeset('r3');

select uid, name, box from hardware;
select uid, name, hardware, switch from box;
select uid, name, box from switch;
\end{minted}

\begin{center}

\begin{table}
    \caption{box}
    \label{tab-comp-box}
\begin{tabular}{ | l | l | l | l |}
    \hline
    \multicolumn{4}{|c|}{box}\\
    \hline
    uid & name & hardware & switch\\
    \hline
    1 & h1 & 1 & \\
    3 & o1 & 2 & \\
    2 & h3 &  & 1\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware}
    \label{tab-comp-hw}
\begin{tabular}{ | l | l | l | }
    \hline
    \multicolumn{3}{|c|}{hardware}\\
    \hline
    uid & name & box\\
    \hline
    1 & h1 & 1\\
    2 & o1 & 3\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{switch}
    \label{tab-comp-switch}
\begin{tabular}{ | l | l | l | }
    \hline
    \multicolumn{3}{|c|}{switch}\\
    \hline
    uid & name & box\\
    \hline
    1 & h3 & 2\\
    \hline
\end{tabular}
\end{table}

\end{center}

\section{Multi-value References}
\label{sec:multi-val}
Multi-value references are described in \ref{sec:relation-multi-value-references}.\\
For each table's attribute, which is a part of some multi-value reference, is generated table, we call it {\em inner table}. This inner table stores for each object from the table its {\tt identifier\_set} value.\\

\subsection{Data Modifications and Versioning}
As inner table stores data of attribute that is part of versioned data, it is needed to have history table for all inner tables as well.\\ 
In addition to ordinary set attribute functions {\tt identifier\_set} attributes could be modified also by functions that insert or remove identifier into or from identifier set.\\
Each inner table has attribute flag that is used to distinguish between rows representing empty set from rows representing NULL value.\\
Following example shows how we can work with {\tt identifier\_set}s. In tables \ref{tab-multi-hosthist} and \ref{tab-multi-innerhist} you can see whole history of objects in the example. The table \ref{tab-multi-hostv} shows result of the last select, it selects data from given version.

\begin{minted}{sql}
select startchangeset();
select service_add('s1');
select service_add('s2');
select service_add('s3');
select host_add('h1');
select host_add('h2');
select host_set_service('h1',ARRAY['s1','s2']);
select commitchangeset('r2');

select startchangeset();
--we can remove just one item from identifier_set
select host_set_service_remove('h1','s2');
--we can insert just one item to identifier_set
select host_set_service_insert('h2','s3');
select commitchangeset('r3');

select startchangeset();
--host h1 has now empty set of services
--flag is still 1
select host_set_service_remove('h1','s1');
select commitchangeset('r4');

select startchangeset();
--flag is now 0
select host_set_service('h1',NULL);
select commitchangeset('r5');

select * from host_history;
select * from inner_host_service_history;
--this is how you can get hosts' services in given version
select uid, name, host_get_service(uid,4) from host_data_version(4);
\end{minted}

\begin{center}

\begin{table}
    \caption{host\_history}
    \label{tab-multi-hosthist}
\begin{tabular}{ | l | l | l | l |}
    \hline
    \multicolumn{4}{|c|}{host}\\
    \hline
    uid & name & dest\_bit & version\\
    \hline
    1 & h1 & 0 & 1\\
    2 & h2 & 0 & 1\\
    1 & h1 & 0 & 2\\
    2 & h2 & 0 & 2\\
    1 & h1 & 0 & 3\\
    1 & h1 & 0 & 4\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{inner\_host\_service\_history}
    \label{tab-multi-innerhist}
\begin{tabular}{ | l | l | l | l |}
    \hline
    \multicolumn{4}{|c|}{inner\_host\_service\_history}\\
    \hline
    host & service & flag & version\\
    \hline
    1 & 1 & 1 & 1\\
    1 & 2 & 1 & 1\\
    1 & 1 & 1 & 2\\
    2 & 3 & 1 & 2\\
    1 &  & 1 & 3\\
    1 &  & 0 & 4\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{host}
    \label{tab-multi-hostv}
\begin{tabular}{ | l | l | l |}
    \hline
    \multicolumn{3}{|c|}{select uid, name, host\_get\_service(uid,4) from host\_data\_version(4)}\\
    \hline
    uid & name & service\\
    \hline
    1 & h1 & \{\}\\
    2 & h2 & \{s3\}\\
    \hline
\end{tabular}
\end{table}

\end{center}

\subsection{Templates}
The table, to which attribute an inner table is made, could also be templated. So it is needed to have template table of these inner tables and have functions for resolving templated inner table's data.\\
Following example shows how we can work with templated {\tt identifier\_set}s. Promised example of function, which retrieves resolved objects' data with the data origin, is introduced in the example. Also the function which process diff data and lists data modifications of {\tt identifier\_set} attributes is showed in the example.\\

\begin{minted}{sql}
select startchangeset();
select service_add('s1');
select service_add('s2');
select service_add('s3');
select host_add('h1');
select host_add('h2');
select host_template_add('t1');
select host_template_add('t2');
select host_template_set_service('t2',ARRAY['s1','s2']);
select host_template_set_template_host('t1','t2');
select host_template_set_note_host('t1','note from t1');
select host_set_template_host('h1','t1');
select host_set_template_host('h2','t2');
select commitchangeset('r2');

select startchangeset();
select host_set_service_remove('h2','s2');
select host_template_set_service_insert('t1','s3');
select commitchangeset('r3');

select host_init_resolved_diff(2,3);
select * from host_diff_refs_set_set_attributes(2,3);
--returns these two rows
--objname:h1 attribute:service olddata:{s1,s2} newdata:{s1,s2,s3}
--objname:h2 attribute:service olddata:{s1,s2} newdata:{s1}

select host_terminate_diff();
\end{minted}

By calling the following selects we can get resolved data with the data origin, it means with inherited values and name of the object from which was the value taken.\\
\begin{minted}{sql}
select * from host_resolved_data_template_info();
select * from host_resolved_data_template_info(2);
\end{minted}

Results are in \ref{tab-multi-reshost}} and \ref{tab-multi-reshostv2}.

\begin{center}

\begin{table}
    \caption{host\_resolved\_data\_template\_info()}
    \label{tab-multi-reshost}
\begin{tabular}{ | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{7}{|c|}{host\_resolved\_data\_template\_info()}\\
    \hline
    uid &  name &  service &  service\_templ &  note\_host &  note\_host\_templ &  template\_host\\
    \hline
    2 & h2 & \{s1\} & h2 &  &  & 2\\
    1 & h1 & \{s1,s2,s3\} & t1 & note from t1 & t1 & 1\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{host\_resolved\_data\_template\_info(2)}
    \label{tab-multi-reshostv2}
\begin{tabular}{ | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{7}{|c|}{host\_resolved\_data\_template\_info(2)}\\
    \hline
    uid &  name &  service &  service\_templ &  note\_host &  note\_host\_templ &  template\_host\\
    \hline
    2 & h2 & \{s1,s2\} & t2 &  &  & 2\\
    1 & h1 & \{s1,s2\} & t2 & note from t1 & t1 & 1\\
    \hline
\end{tabular}
\end{table}


\end{center}


\end{document}
