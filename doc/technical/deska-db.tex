\documentclass[deska]{subfiles}
\begin{document}

\chapter{Deska DB}
\label{sec:deksa-db}

\begin{abstract}
FIXME: talk about deska db - versioning, data resolving
\end{abstract}

In this chapter you can find how the deska db works, how the data versioning, templating and other deska's features are done.\\
Almost all tables and stored procedures are generated by sql-generator described in \secref{sec:sql-generator}.

\section{Versioning}
The database can return object's data in any version in which it exists. This could be done due to history tables that are generated for each table defined by user.\\
Each history table contains, in addition to attributes in the table defined by user, attributes {\tt version} and {\tt dest\_bit}. In version attribute is information about the changeset in which the object was modified. {\tt dest\_bit} attribute set to 1 means that the object is deleted, default value is 0.\\

\subsection{Data Modification}
\begin{center}

\begin{table}
    \caption{history of hardware table}
    \label{tab-example-hardwarehist}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_history}\\
    \hline
    name & uid & purchase & note & dets\_bit & version\\
    \hline
    h1 & 1 & & & 0 & 1 \\
    h2 & 2 & & & 0 & 1 \\
    h2 & 2 & & note & 0 & 2 \\
    h2 & 2 & 01-01-2011 & note & 0 & 3 \\
    h1 & 2 & & & 1 & 3 \\
    \hline
\end{tabular}
\end{table}

\end{center}

In table \ref{tab-example-hardwarehist} is example history of hardware. This is how the hardware\_history table looks like after following operations. 
\begin{itemize}
    \item In changeset 1 were inserted hardware h1, h2. \\
    \item In changeset 2 was h2's note attribute set to note.
    \item In changeset 3 was h2's purchase attribute set to 01-01-2011 and hardware h1 was deleted.
\end{itemize}


If this was only part of data from hardware\_history table then we could not recognize if these objects were in changeset 1 created or some of their attribute was just set.\\
In row with hardware h2, version 3 we can see that when object is modified, row with its actual data and id of current changeset is inserted into history table, after that the attribute which has to be modified is set.\\
In words of stored procedures it could be written so:

\begin{minted}{sql}
select startchangeset();
select hardware_add('h1');
select hardware_add('h2');
select commitchangeset('.');

select startchangeset();
select hardware_set_note('h2','note');
select commitchangeset('.');

select startchangeset();
select hardware_set_purchase('h2','01-01-2011');
select hardware_del('h1');
select commitchangeset('.');
\end{minted}

\subsection{Retrieve Object Data}

\end{center}

If we would like to get data of some objects in given version. We have to find the objects' last modification. To find the really last objects' modification, we need to know version table.\\
At the time of changeset commit, table with versions is updated. For our example it could looks like \ref{tab-example-version}.\\
Important infomation for us are id and num. id is id of changeset from which the version num was created. The version number num is an increasing sequence, if version num2 was created on the base of version num1 then num1 < num2.

\begin{center}

\begin{table}
    \caption{version table}
    \label{tab-example-version}
\begin{tabular}{ | l | l | l | l | l |}
    \hline
    \multicolumn{5}{|c|}{version}\\
    \hline
    id & num & author & timestamp & message\\
    \hline
    0 & 1 & martina & 2011-12-17 17:04:29.56794 & Initial revision\\
    1 & 2 & martina & 2011-12-17 17:04:47.876152 & .\\
    2 & 3 & martina & 2011-12-17 17:04:54.731837 & .\\
    3 & 4 & martina & 2011-12-17 17:05:12.489788 & .\\
    \hline
\end{tabular}
\end{table}

\end{center}


There are some examples of data retriving, results are in table \ref{tab-select-hardware} and table \ref{tab-select-hardware-v3}.

\begin{minted}{sql}
select * from hardware_data_version();
select * from hardware_data_version(3);
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware\_data\_version()}
    \label{tab-select-hardware}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_data\_version()}\\
    \hline
    uid & name & note & purchase & dets\_bit & version\\
    \hline
    2 & h2 & note & 2011-01-01 & 3 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

\begin{center}

\begin{table}
    \caption{hardware\_data\_version(3)}
    \label{tab-select-hardware-v3}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware\_data\_version(3)}\\
    \hline
    uid & name & note  & purchase& dets\_bit & version\\
    \hline
    1 & h1 &  &  & 1 & 0\\
    2 & h2 & note &  & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

\subsection{Commit}
Commit function selects objects from history table of given kind which were just added, deleted or updated in the current changeset. Rows that belong to added objects are inserted into given kind's table in the schema production. Rows that belong to deleted objects are deleted from kind's table in the schema production. And rows that belong to updated objects are updated in kind's table in the schema production.\\
Commits of our example will cause this changes:
\begin{itemize}
    \item After changeset 1 rows with hardware h1, h2 will be inserted.
    \item After changeset 2 h2's note attribute will be updated.
    \item After changeset 3 h2's purchase attribute will be updated and hardware h1 will be deleted.
\end{itemize}

\section{Refers To}
If the table is in the {\tt refers to} relation with another, it has to have column that refers to the {\tt uid} column of the another table. This column, which refers to the {\tt uid} column of another table, we will call here {\em refuid}.\\
Stored procedures for setting refuid columns expect as parameter some value of name attribute from referenced table. The given name is found in referenced table and proper {\tt uid} is set as value of refuid column instead of the name.

Here is an example of setting refuid column. The result of these selects is in tables \ref{tab-refs-hardware} and  \ref{tab-refs-vendor}.
\begin{minted}{sql}
select startchangeset();
select vendor_add('v1');
select vendor_add('v2');
select hardware_add('h1');
select hardware_set_vendor('h1','v2');
select commitchangeset('.');
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware}
    \label{tab-refs-hardware}
\begin{tabular}{ | l | l | l | l | l |}
    \hline
    \multicolumn{5}{|c|}{hardware}\\
    \hline
    uid & name & note & purchase & vendor\\
    \hline
    1 & h1 &  &  & 2\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{vendor}
    \label{tab-refs-vendor}
\begin{tabular}{ | l | l |}
    \hline
    \multicolumn{2}{|c|}{vendor}\\
    \hline
    uid & name \\
    \hline
    1 & v1\\
    2 & v2\\
    \hline
\end{tabular}
\end{table}

\end{center}

\section{Embed into}

\section{Templates}
{\tt TEMPLATIZED} relation which is described in \ref{} is implemented by template tables. 

\subsection{Value inheritence}
The columns, which are a part of some {\tt composition} relation or {\tt embed into} relation, can not inherit its value from templates. Therefor these columns are not present in the template table. All other attributes from the templated table are in the template table.\\
As the template tables are templated by themself, object can inherit value of its attributes transitively from more templates.\\
To ensure right data retrieving in given version, template tables need to have history tables as well.\\
The following example shows how we can work with the templated tables. The hardware table is templated by the hardware\_template table. The result of these selects is in tables \ref{tab-templ-hwhist} and \ref{tab-templ-hwtemplhist}.

\begin{minted}{sql}
select startchangeset();
select hardware_template_add('t1');
select hardware_template_set_note('t1','note from template t1');
select hardware_template_set_purchase('t1','01-01-2011');
select hardware_add('h1');
select hardware_set_template_hw('h1','t1');
select commitchangeset('r2');

select startchangeset();
select vendor_add('v1');
select hardware_template_add('t2');
select hardware_template_set_vendor('t2','v1');
select hardware_template_set_purchase('t2','01-01-2011');
select hardware_template_set_template_hw('t1','t2');
select commitchangeset('r3');

select startchangeset();
select hardware_set_note('h1','own h1 note');
select commitchangeset('r4');
\end{minted}

\begin{center}

\begin{table}
    \caption{hardware\_history}
    \label{tab-templ-hwhist}
\begin{tabular}{ | l | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{8}{|c|}{hardware\_history}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & version & dest\_bit\\
    \hline
    1 & h1 &  &  &  & 1 & 1 & 0\\
    1 & h1 & own h1 note &  &  & 1 & 3 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template\_history}
    \label{tab-templ-hwtemplhist}
\begin{tabular}{ | l | l | l | l | l | l | l | l | }
    \hline
    \multicolumn{8}{|c|}{hardware\_template\_history}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & version & dest\_bit\\
    \hline
    1 & t1 & note from template t1 & 2011-01-01 &  &  & 1 & 0\\
    2 & t2 &  & 2011-01-01 & 1 &  & 2 & 0\\
    1 & t1 & note from template t1 & 2011-01-01 &  & 2 & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\end{center}

By calling the following commands we can get resolved data, it means with inherited values.
\begin{minted}{sql}
--from version 'r3'
select * from hardware_resolved_data(3);
select * from hardware_template_resolved_data(3);
\end{minted}
Results are in \ref{tab-templ-hwres2} and \ref{tab-templ-hwtemplres2}.

\begin{minted}{sql}
--in production are the newest resolved data
select * from hardware;
select * from hardware_template;
\end{minted}
Results are in \ref{tab-templ-hw} and \ref{tab-templ-hwtempl}.

\begin{center}

\begin{table}
    \caption{hardware\_resolved\_data(3)}
    \label{tab-templ-hwres2}
\begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    \multicolumn{7}{|c|}{hardware\_resolved\_data()}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & dest\_bit\\
    \hline
    h1 & 1 & note from template t1 & 2011-01-01 & 1 & 1 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template\_resolved\_data(3)}
    \label{tab-templ-hwtemplres2}
\begin{tabular}{ | l | l | l | l | l | l | l |}
    \hline
    \multicolumn{7}{|c|}{hardware\_template\_resolved\_data(3)}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw & dest\_bit\\
    \hline
    t2 & 2 &  & 2011-01-01 & 1 &  & 0\\
    t1 & 1 & note from template t1 & 2011-01-01 & 1 & 2 & 0\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware}
    \label{tab-templ-hw}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{6}{|c|}{hardware}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw\\
    \hline
    1 & h1 & own h1 note & 2011-01-01 & 1 & 1\\
    \hline
\end{tabular}
\end{table}

\begin{table}
    \caption{hardware\_template}
    \label{tab-templ-hwtempl}
\begin{tabular}{ | l | l | l | l | l | l |}
    \hline
    \multicolumn{7}{|c|}{hardware\_template}\\
    \hline
    uid & name & note & purchase & vendor & template\_hw\\
    \hline
    1 & t1 & note from template t1 & 2011-01-01 & 1 & 2\\
    2 & t2 &  & 2011-01-01 & 1 & \\
    \hline
\end{tabular}
\end{table}

\end{center}

\subsection{Commit of Templated Tables}

\section{Diff}

\section{Composition}

\section{Multi-value References}

\end{document}
