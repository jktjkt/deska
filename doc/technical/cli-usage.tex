% vim: spelllang=en spell textwidth=120
\documentclass[deska]{subfiles}
\begin{document}

\chapter{The Console Application}
\label{sec:usage-cli}

\begin{abstract}
The following chapter serves as a users' guide to the CLI application.
\end{abstract}

\todo{Tomas: please use a proper markup (\\tt etc.) throughout this section. A command shall be shown in an appropriate
typeface.}

\section{Prompt and context}

When the CLI is started, you will se the command prompt, where the commands could be entered. The prompt has its context.
The context is something like a path to some object where each object in the path is nested to the previous. 
It means, that all commands manipulating, or working with objects will now be related to this context. This behavior
is very similar to an ordinary unix prompt where under context we can imagine a current directory where we are. Actually the
context could represent a set of objects, because it can contain also filters, not only single object definitions.
We will talk about filters later. Context means, that all commands manipulating, or working with objects will now be related to
object or objects represented by this context. This behavior is very similar to an ordinary unix prompt where under context
we can imagine a current directory where we are. In unix prompt all commands like "ls", "cd", "mv" and so on are also related
to the current directory.

You can go into the context of some object simply by typing its kind and name. For example:

\begin{minted}{text}
> host hpv2
host hpv2> interface eth0
host hpv2->interface eth0>
\end{minted}

Now we are in context of object interface "interface eth0" embedded in "host hpv2". Stepping from the context is done by
keyword "end".

There is also a possibility of shortened types of jumping into context of a nested object using "->" in the name of the
object.

\begin{minted}{text}
> interface hpv2->eth0
host hpv2->interface eth0> end
host hpv2> end
>
\end{minted}

The "interface hpv2->eth0" is equivalent to "host hpv2 interface eth0". So also keyword "end" will jump into context of
"host hpv2" and not to a "top-level" context. This shortened version could be used also in commands manipulating with
objects.

\subsection{Filters}

Now we can describe, how to use filters in the context. Filter could be entered by typing kind name followed by keyword
"where" and then writing filter definition in braces. The filter definition syntax could be described as this recursive
structure:

\begin{minted}{text}
<filter>     = (<andFilter>) or (<orFilter>) or (<expression>)
<andFilter>  = list of <filter> separated by '&'
<orFilter>   = list of <filter> separated by '|'
<expression> = comparison of attribute name and some value
\end{minted}

Note that each part of the filter has to be in braces. In a filter for a specific kind you can use expressions containing
attributes directly from this kind, or kinds, that are contained in this one. There is also possibility to use expressions
containing attributes of any kind, that is in some relation with this one. With relations we mean standard Deska relations
like "embed into", "contains" and "containable" and "refers to". These attributes should be prefixed by name of their
kind with dot. For example "interface.ipv4". There are two sets of operators, that can be used in expressions. First
set is for standard attributes: "<", ">", "<=", ">=", "!=" or "<>" and "=" or "==". The second set is for identifiers
sets. There are only two operators: "contains" and "not\_contains".

Filters are an exception in a concept of context. Normally we can not be in context of a specific interface without being
in context of its host. Filters are a little bit different as a set of interfaces should not have one shared parent. So
when being in top-level context, we can write filter on any kind. When being in context of some object, this filter
relates to this context and we can filter only on objects and kinds, that are embedded directly or recursively in this object.

Now we will show some examples of filters:

Filter on hardware from a specific vendor:
\begin{minted}{text}
> hardware where (vendor == HP)
filter on hardware> end
>
\end{minted}

This was filter using attribute directly from hardware. We can also ask for the same thing using attribute from vendor.
\begin{minted}{text}
> hardware where (vendor.name == HP)
filter on hardware> end
>
\end{minted}

Now we can write filter for hardware not purchased in 2010 serving as www server.

\begin{minted}{text}
> hardware where (((purchase < 2010/01/01) | (purchase > 2010/12/31)) & (host.service contains www))
filter on hardware> end
>
\end{minted}

There are also two special filters. One is for selecting all instances of a specific kind. This is done by keyword "all".
\begin{minted}{text}
> all host
filter on host> end
>
\end{minted}

We can use this filter also for for example all interfaces of a specific host.
\begin{minted}{text}
> host hpv2
host hpv2> all interface
host hpv2->filter on interface> end
host hpv2>
>
\end{minted}

The second filter is for obtaining last added embedded object using keyword "new". The usage is the same as in case of
"all". We will describe usage of both keywords later.

\section{Showing content of the DB}

There are two ways to look at what is currently stored in the DB. First way is showing content of the whole DB. This
is done by command "dump".

Command "dump" recursively shows all objects in the DB including their attributes and nested objects. No other
relations are displayed in this format. This command also accepts an optional parameter to redirect the command's output
to the specified file.

The sample dump can look like this:
\begin{minted}{text}
> dump
host hpv2
    no hardware
    note_host "Sample host"
    service [ftp, www]
    no template_host
    no virtual_hardware
    interface eth0
        ip4 192.168.2.34
        no ip6
        mac 2E:4A:AB:89:6C:7B
        no network
        no note
        no template_interface
    end
end
host golias2
    no hardware
    note_host "Another sample host"
    no service
    no template_host
    no virtual_hardware
end
service www
    no note
end
service ftp
    no note
end
service dns
    no note
end
\end{minted}

Another method is using command "show". When the user has not entered a context yet, this command shows only list of top-level objects without any
additional information. When in a context, it will display information about object or objects from the current context. The
information contains all attributes with resolved values from templates. When some attribute value was taken from
a template, information about source of this value is also printed. If some object is contained in one being currently
printed, its attributes and nested kinds will be printed under attribute referring to that object. Nested objects are
printed in a way similar to the output from the command "dump". Example of output from "show" on a host containing some hardware
through attribute "hardware" with attribute "ram" inherited from template for hardware with name "hp357":

\begin{minted}{text}
> host hpv2
host hpv2> show
hardware hpv2
cpu_ht 1
cpu_num 4
no hepcpec
host hpv2
no note_hardware
purchase 2011-12-23
ram 4096 -> hp357
template_hardware hp357
no vendor
warranty 2013-12-23
note_host "Sample host"
no service [ftp, www]
no template_host
no virtual_hardware
interface eth0
    ip4 192.168.2.34
    no ip6
    mac 2E:4A:AB:89:6C:7B
    no network
    no note
    no template_interface
end
\end{minted}

Command "show" could be used also for printing information about objects outside of the current context. Like "show host hpv2" or
"show host hpv2 interface eth0". This form will print the requested information without changing the current context.
The parameter can refer both to the top-level objects and to those in the current context. It means that in context of host "hpv2" you can type "show interface eth0"
for showing information about interface "eth0" nested in host "hpv2".

\section{Modifying objects and their attributes}

In this section we describe how to create, rename and delete object and also how to set or remove a value of their
attributes.

\subsection{Objects creating, deleting and renaming}

There are three ways on how to create an object. First one is an explicit one using keyword "create". For example "create
host hpv2" will create object "host hpv2". You can also directly create nested object (including its parent, if it
doesn't exist yet) using a single "create host hpv2 interface eth0" call. Note that the keyword "create" does not change
the current context, but acts as a standalone action -- an object is created, but the user's context remains the same.
Second way how to create an object is through an attempt to step into the context on a non-existing object.
When trying to do that, CLI will ask you if you want to create this object. Obviously, this second will change the
context, for example:

\begin{minted}{text}
> host hpv2
Object(s) host hpv2 do(es) not exist. Create? y
host hpv2> end
> host hpv2
host hpv2> end
>
\end{minted}

When going into the context of a nested object where the parent does not exist either, the CLI will ask only for creating the
parent --- as the parent did not exist previously, the user surely intends to create the second object as well.
\todo{Tomas: tohle nemusi byt pravda, protoze pak takovy preklep v prikazu ``host preklepnuty interface eth1'' ma
potencial zalozit eth1, ackoli uzivatel napr. chtel jit do stareho eth0. Nevim, je to ku zvazeni, smas tohle todo,
chces-li. -- Honza}

Finally, the third way of creating an object is through the {\tt new} keyword. This command works only on the nested
objects, and lets the server assign a name to the newly created object automatically. This feature is useful when creating
new object where the custom name does not make much sense. You specify only the kind name after this keyword new:

\begin{minted}{text}
> hardware ibm458
hardware ibm458> new failure
hardware ibm458->failure failure_1> end
hardware ibm458> new failure
hardware ibm458->failure failure_2> end
hardware ibm458> last failure
hardware ibm458->failure failure_2> end
hardware ibm458> new failure
hardware ibm458->failure failure_3> end
hardware ibm458> last failure
hardware ibm458->failure failure_3> end
hardware ibm458> end
>
\end{minted}

Please keep in mind that the user cannot make any assumptions about the newly assigned name.  The current server
implementation will use a monotonous sequence as the bases for the name, but extensions are free to change this behavior
to e.g. include timestamps in the created names, etc.

In this example you can see that the keyword new changes the context, and that it is possible to step into the context
of the newest object through the keyword {\tt last}.  This might come handy when working with ``append-only'' objects
like in an event log.

Deleting objects is similar to creating. It is done using keyword "delete". You can use the same parameters as in
create, like "delete host hpv2". When you are trying to delete a nested object directly, use "delete host hpv2 interface
eth0". This will delete only the interface, not the whole host. When deleting parent of some nested objects, CLI will
also delete all these nested objects (after confirmation).

\todo{Tomas: can I use {\tt delete interface hpv2->eth0}? If not, why not?}

Renaming of objects is also very simple, through the {\tt rename} keyword. The format of
parameter for "rename" is the same as for create, but you have to specify the new name as the last word. For example
"rename host hpv2 hpv3" will rename host "hpv2" to "hpv3". When you are renaming an object which is connected using relation
"contains" or "containable" to another objects, the CLI will ask you if you want to rename these connected objects
as well as they have the same name. If you do not rename them, the connection between them will be lost.

For renaming, creating and deleting objects you can also use filters. Here is the example of deleting all interfaces from
a host with some specific characteristic:

\begin{minted}{text}
> host hpv2
host hpv2> delete interface where (note == "to delete")
Are you sure you want to delete objects(s) interface from filter? y
host hpv2> end
>
\end{minted}

\subsection{Modifying attributes}

The simplest way of modifying an attribute of a specific object is by typing the attribute name and then the desired value
when being in context of the object:

\begin{minted}{text}
> host hpv2
host hpv2> ip4 192.168.25.65
host hpv2>
\end{minted}

You can also remove the value of the attribute using keyword "no". For example "no ip4". There are also two special
keywords for operations with identifier sets. It is keyword "add" for adding an identifier to a set and keyword
"remove" for removing an identifier from a set --- e.g. "add service www" for adding identifier "www" to a set
with name service. You also set the set directly as a value of standard attribute using the notion "service [ftp, www,
dns]", which simply overwrites the current value with the specified data.

Here is the list of all supported types and syntax for the values:

\begin{itemize}
    \item{String} - Characters in quotes or apostrophes when containing spaces, or characters without any spaces
    \item{Identifier} - List of alphanumerical letters and {\tt -} or {\tt \_}, not ending with {\tt -}, separated by
        {\tt ->} (when containing more than two items)
    \item{Identifier set} - List of Identifiers in square brackets ({\tt []} separated by comma ({\tt ,})
    \item{IP Address v4} - The dot-decimal notation~\cite{ipv4-dot-decimal}
    \item{IP Address v6} - Various supported formats~\cite{rfc5952}
    \item{MAC Address} - IEEE~802 format with colon as separators and lowercase letters
    \item{Integer} - Integer
    \item{Double} - Double
    \item{Boolean} - strings "true" or "false"
    \item{Date} - Date in the {\tt YYYY-MM-DD} format
    \item{Timestamp} - Timestamp in the {\tt YYYY-MM-DD HH:MM:SS} format.  Seconds optionally accept decimal fraction.
\end{itemize} 

\section{Database Backup}
\label{sec:cli-db-backup}

\todo{Tomas: describe me}

\end{document}
