% vim: spelllang=en spell textwidth=120
\documentclass[deska]{subfiles}
\begin{document}

\chapter{The Console Application}
\label{sec:cli-app}

\begin{abstract}

In this chapter you can find the description of the {\tt Deska CLI}, the user interface for the whole system.

\end{abstract}

\section{Components}

The whole user interface is composed of five main components and two supporting ones.

When describing the architecture in direction from the DB, the first component is {\tt Deska::Cli::DbInteraction}. The 
whole CLI communicates with the DB through this class. The second part on our way to the user is {\tt Deska::Cli::UserInterface}.
Here you can find all definitions for single commands you can type to the command line, 
event loop handler and logics of communication with the user. This class is connected to another important component 
called simply, {\tt Parser}. All classes related to the CLI are placed in the namespace {\tt Deska::Cli}, so this one is not an 
exception and you can find it as class {\tt Deska::Cli::Parser}. This component is responsible for parsing of the 
command line. Each action, that user wans to perform writing it to the command line is represented by a signal emitted 
by this parser. All these signals are collected in a supporting component called {\tt SignalsHandler} and the {\tt Parser}
is then connected with the {\tt UserInterface} through this component. {\tt UserInterface} is also directly 
connected to the closest part of the application to the user, the {\tt UserInterfaceIO}. This class stands for a 
translator between questions and responses from the {\tt UserInterface} and the end user. Besides these five 
components, there is one more. The whole CLI needs some configuration values for it's work. For obtaining these values 
is responsible {\tt Deska::Cli::CliConfig}.

Now we can describe all components in more detail.

\section{DbInteraction}

In the CLI part of Deska are used specific structures for manipulating data from the DB. We will describe firstly 
these structures, and then the role of {\tt DbInteraction}.

\subsection{Structures}

First structure is {\tt AttributeDefinition}. This one is very simple. It is containing attribute name ({\tt Db::Identifier}))
and it's value ({\tt Db::Value}). {\tt AttributeDefinition} is not fully determined by itself as it 
does not contain any information about object to which this attribute with value belongs. So another structure is {\tt ObjectDefinition}.
This one is very similar to {\tt AttributeDefinition}, because it is also representing some kind of 
key - value structure. It contains kind name ({\tt Db::Identifier})) and object name ({\tt Db::Identifier})). The name 
is fully qualified, so in case of one object embedded using relations to another, this name will contain symbol "->" 
and both names. For example when we imagine kind "host" and embedded kind "interface". We can have one host -- "hpv2" 
and it's "interface" -- "eth0". Now the {\tt ObjectDefinition} for this interface will have kind "interface" and name 
"hpv2->eth0". And now, when we have pair of {\tt AttributeDefinition} and {\tt ObjectDefinition}, we perfectly know, 
what value of which attribute belongs to a specific object. These structures are used for both assigning and obtaining 
the attributes from DB or creating objects. Another structure is a little bit more complicated. It is {\tt ContextStack}
and {\tt ContextStackItem}. {\tt ContextStack} is only a simple {\tt std::vector} of {\tt ContextStackItem} instances.
Under {\tt ContextStack} you can imagine some kind of path in directory structure on your computer where one item is not
a folder, but it is an object. When we use our example of {\tt ObjectDefinition}, the {\tt ContextStack} representing
the "interface eth0" will have two instances of {\tt ContextStackItem}: "host hpv2" and "interface eth0". You can see,
that in opposite to the {\tt ObjectDefinition}, {\tt ContextStackItem} is not fully qualified by itself. You must have
the whole {\tt ContextStack} in order to know which object is it representing. Till now we were talking about
{\tt ContextStack} representing only one object. In this case, {\tt ContextStack} contains only something like
instances of {\tt ObjectDefinition} without fully qualified names. {\tt ContextStackItem} could also represent a filter.
In this case it is a pair of kind name and {\tt Db::Filter}. Using context stack with a filter you can address a set of
objects with a specific characteristic. For example all interfaces of object "host hpv2" that belongs to a specific
network.

Because the work in the CLI is based mostly on the context stack as it is a natural way how to deal with the structure
of data in the DB and DBAPI is based on functions working with single objects or filters, we have the implemented the
class {\tt DbInteraction} to deal with conversion from context stack to format that is suitable for DBAPI.

\subsection{Context stack conversion}

As we described earlier, the context stack can be simple, without filters or more complicated with filters.

Conversion of {\tt ContextStack} to a single {\tt ObjectDefinition} is possible only when the {\tt ContextStack} does
not contain any filters. This type of conversion is very straight forward and could be done without queries to the DB.
We simply concatenate all object names from the stack with "->" symbol and use kind name from the last kind in the stack.

When we want to convert {\tt ContextStack} with filters, we have to perform queries to the DB. The conversion is made
step by step when going through the stack. In every time of the conversion we have a vector of all objects matching current
level of context stack. When the {\tt ContextStackItem} is representing an object, we only extend all names in the vector
with the "->" symbol and the object name from the {\tt ContextStackItem} and use kind name from the {\tt ContextStackItem}.
When the {\tt ContextStackItem} is representing a filter, we have to construct a large filter. Firstly we have to construct
a filter matching all objects in the vector. This is done by {\tt Db::OrFilter} containing all object names. Then we use
this filter together with filter from {\tt ContextStackItem} in a {\tt Db::AndFilter}. Now we have filter matching new
level of context stack, that can be used for performing operations through DBAPI.

\subsection{Caching}

Another role of class {\tt DbInteraction} is caching of several types of data to reduce network traffic, delays and
server load.

First caching is made on DB structure. {\tt DbInteraction} stores names of kinds and their attributes in several maps
(we used nested {\tt std::map} for implementation of these structures) for fast access to data needed for oparations with
the DB. Information like to which kind each attribute refers, in which kind is some kind embedded and more are stored
here.

Another chaching is performed on querries checking if some object exists or not, as these querries are quite frequent.
Because all queries to the DB are performed through this class, we can update our cache while performing modification to
the DB like creating objects, deleting objects, renaming objects and so on.

\section{UserInterface}

Class {\tt UserInterface} is the central class holding the logics of the CLI. This class serves like a glue connecting
all other components together.

It is driven by two types of commands. First type are commands implemented as classes inherited from {\tt CliCommand}.

\begin{minted}{c++}
class Command
{
public:
    Command(UserInterface *userInterface);
    virtual ~Command();
    virtual bool operator()(const std::string &params) = 0;
protected:
    std::vector<std::string> complPatterns;
    std::string cmdName;
    std::string cmdUsage;
};
\end{minted}

As you can see, the base is very simple. In constructor several mandatory variables of the class are set like
completion patterns, command name, and usage description for help generation. These commands are infuencing the rest of
the Deska through pointer to {\tt UserInterface}. These command classes are stored in a map with their names as a key.
After that they are picked up using this name. Executing the command is made by calling function {\tt bool operator()} with
string as a parameter. This parameter could be then processed to influence behavior of each command. Return value is here
to tell the other world is the executing of the command succeeded or not. Names and parameters of these commands
are indepent on DB structure. Their purpose are things like operations with changesets, dumping, backuping and restoring
the DB and so on. We will describe each command separately in more detail later.

The second type of commands are dependent on DB structure. They are used for manipulating data in the DB like setting attributes,
creating, deleting and renaming objects and so on. Because of the fact, that these actions are performed using calls
like "<attribute-name> <attribute-value>" or "<kind-name>" "<object-name>", you can see, that here actualy is not any
name for this command. It is fully determined by the action it should perform. A special class was developped for parsing
of these "commands", class {\tt Parser}. It is one of the main components and also one of the most complicated, so we will
describe it later in a separate section. The parser itself does not change the datain the DB. It communicates with the
{\tt UserInterface} through simple class {\tt SignalsHandler}. This class is here because the parser emmits signals for
each action. These signals are caught and stored in the {\tt SignalsHandler}. Then comes two way processing of the stack,
where in the first round each action represented by one signal is confirmed and then when all signels are confirmed, they
are applyed to the DB. The confirmation and applying is performed via functions implemented in the {\tt UserInterface},
that you can see on the following snippet.

\begin{minted}{c++}
class UserInterface: public boost::noncopyable
{
public:

...

    bool applyCreateObject(const ContextStack &context,
            const Db::Identifier &kind, const Db::Identifier &object, ContextStackItem &newItem);
    bool applyCategoryEntered(const ContextStack &context,
            const Db::Identifier &kind, const Db::Identifier &object, ContextStackItem &newItem);
    bool applySetAttribute(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Value &value);
    bool applySetAttributeInsert(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Identifier &value);
    bool applySetAttributeRemove(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Identifier &value);
    bool applyRemoveAttribute(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute);
    bool applyObjectsFilter(const ContextStack &context, const Db::Identifier &kind,
            const boost::optional<Db::Filter> &filter);
    bool applyFunctionShow(const ContextStack &context);
    bool applyFunctionDelete(const ContextStack &context);
    bool applyFunctionRename(const ContextStack &context, const Db::Identifier &newName);

    bool confirmCreateObject(const ContextStack &context,
            const Db::Identifier &kind, const Db::Identifier &object);
    bool confirmCategoryEntered(const ContextStack &context,
            const Db::Identifier &kind, const Db::Identifier &object, bool &autoCreate);
    bool confirmSetAttribute(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Value &value);
    bool confirmSetAttributeInsert(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Identifier &value);
    bool confirmSetAttributeRemove(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute, const Db::Identifier &value);
    bool confirmRemoveAttribute(const ContextStack &context, const Db::Identifier &kind,
            const Db::Identifier &attribute);
    bool confirmObjectsFilter(const ContextStack &context, const Db::Identifier &kind,
            const boost::optional<Db::Filter> &filter);
    bool confirmFunctionShow(const ContextStack &context);
    bool confirmFunctionDelete(const ContextStack &context);
    bool confirmFunctionRename(const ContextStack &context, const Db::Identifier &newName);

...

};
\end{minted}

Now we will describe how each command from the first group works.

\subsection{Start}

This one is very simple. It only starts and connects to a new changeset.

\subsection{Resume}

Class {\tt Resume} is here to connect user to some pending changeset. Choosing procedure is implemented in the IO part of
the Deska, in class {\tt UserInterfaceIO}, which will be described later. 

\subsection{Detach}

Class implementing command "detach" is also very simple. It only obtains detach message from the user using
class {\tt UserInterfaceIO} and detaches from current changeset.

\subsection{Abort}

{\tt Abort} is here only to detach from the current changeset and dispose it.

\subsection{Rebase}

Class {\tt Rebase} is quite complicated one. It's purpose is to reconnect current changeset from it's parent to a new
one. This is done firstly by creating a new changeset, which will be connected to a newest revision and then by performing
the same changes as we performed in old changeset in this changeset. Then we can abort the old changeset. Well we can not
perform exactly the same changes in our new changeset, because the DB could change that it could not be possible. For
example when we set attribute of some object which was deleted in a newer revision. To solve this problem we are performing
some kind of merge here. We obtain two sets of {\tt Db::ObjectModificationResult}. Firs is diff between our old changeset
and it's parent. This gives us list of our changes. Next set is diff between parent of our old changeset and parent of a
new changeset. This represents changeset made while we were working in our old changeset. These sets has to be somehow
merged and shown to a user in order to see, haw the final result of merge will look like and also in order to influence
the result of this merge. The merge is performed by several comparators and the result has to be in the following order:
\begin{enumerate}
    \item {\tt Db::DeleteObjectModification}
    \item {\tt Db::RenameObjectModification}
    \item {\tt Db::CreateObjectModification}
    \item {\tt Db::SetAttributeModification}
\end{enumerate}
This order was chosen because of constraints in the DB. For example when we are creating some object, the object with
the same name must not exist and so on. So deleting does not break any constraint any time. Rename is before create
because you can create then the object of the same name as an old one, but you will never need to perform create before
rename to unblock rename. Setting attributes must be last as it requires an existing object. After this sorting and
merging the result is shown to the user using an interactive editor implemented in {\tt UserInterfaceIO}. Here the user
can delete or modify the modifications. When the editting part is finished, the corrected list is processed and
all modifications are performed.

\subsection{Status}

{\tt Status} is on of the simpliest classes as it only informs user if he is connected to some changeset or not by looking
to one variable stored in {\tt UserInterface}.

\subsection{NonInteractive}

This class is not complicated as well. It toggles boolean variable in {\tt UserInterface} signalising if the user will
be asked for confirmations of some actions or if they will be confirmed automaticaly.

\subsection{Log}

Function {\tt bool Log::operator()} when executed without parameters only obtains list of all revisions in the DB and
prints this list using {\tt UserInterfaceIO} to the screen. The more interesting part of this class is parameters parser.
It is based on {\tt boost::spirit} as well as the {\tt Parser}. Parsing of parameters is done by class {\tt LogFilterParser}. 



\end{document}
